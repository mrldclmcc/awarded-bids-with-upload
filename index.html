<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Awarded Bids Formatter v2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #1a1a1a;
            --primary-hover: #333333;
            --secondary: #666666;
            --background: #fafafa;
            --surface: #ffffff;
            --surface-alt: #f5f5f5;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border: #e0e0e0;
            --success: #2d7d32;
            --error: #d32f2f;
            --warning: #f57c00;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--background);
            min-height: 100vh;
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.5;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
        }

        .header::before {
            display: none;
        }

        .header h1 {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 1rem;
            letter-spacing: -0.02em;
        }

        .header p {
            font-size: 1.25rem;
            color: var(--text-secondary);
            font-weight: 300;
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 2rem;
            overflow: hidden;
            transition: box-shadow 0.2s ease;
        }

        .card::before {
            display: none;
        }

        .card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            background: var(--surface-alt);
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
        }

        .card-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .step-number {
            background: var(--primary);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
        }

        .card-content {
            padding: 2rem;
        }

        .instructions {
            background: var(--surface-alt);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .instructions::before {
            content: 'üí°';
            position: absolute;
            top: 1rem;
            left: 1rem;
            font-size: 1.25rem;
        }

        .instructions p {
            margin-left: 2rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .instructions strong {
            color: var(--text-primary);
        }

        #dataInput {
            width: 100%;
            height: 250px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 13px;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            color: var(--text-primary);
            resize: vertical;
            transition: border-color 0.2s ease;
        }

        #dataInput:focus {
            outline: none;
            border-color: var(--primary);
        }

        #dataInput::placeholder {
            color: var(--text-muted);
        }

        .button-row {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.875rem 2rem;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 44px;
        }

        .btn::before {
            display: none;
        }

        .btn:hover::before {
            display: none;
        }

        .btn:hover {
            background: var(--primary-hover);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--surface-light), var(--surface));
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #059669);
        }

        .btn-success:hover {
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.3);
        }

        .btn-upload {
            background: linear-gradient(135deg, var(--secondary), #d97706);
            position: relative;
        }

        .btn-upload:hover {
            box-shadow: 0 10px 30px rgba(245, 158, 11, 0.3);
        }

        #fileInput {
            display: none;
        }

        #outputPreview {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            min-height: 400px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            overflow-y: auto;
            color: var(--text-primary);
            position: relative;
        }

        #outputPreview:empty::before {
            content: 'Your beautifully formatted output will appear here...';
            color: var(--text-muted);
            font-style: italic;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .status {
            margin: 1rem 0;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            text-align: center;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .status.success {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status.success::before {
            content: '‚úÖ';
        }

        .status.error {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .status.error::before {
            content: '‚ùå';
        }

        .hidden {
            display: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .card-content {
                padding: 1.5rem;
            }

            .button-row {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }

            #dataInput {
                height: 200px;
            }

            .header h1 {
                font-size: 2.5rem;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--surface);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Animations */
        .card {
            animation: fadeInUp 0.6s ease forwards;
        }

        .card:nth-child(2) {
            animation-delay: 0.1s;
        }

        .card:nth-child(3) {
            animation-delay: 0.2s;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Output formatting */
        #outputPreview strong {
            color: var(--primary);
            font-weight: 600;
        }

        #outputPreview br + strong {
            margin-top: 0.5rem;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Awarded Bids Formatter</h1>
            <p>Convert Excel data to email-ready format</p>
        </div>
        
        <div class="card">
            <div class="card-header">
                <h2><span class="step-number">1</span>Input Data</h2>
            </div>
            <div class="card-content">
                <div class="instructions">
                    <p><strong>Instructions:</strong> Copy data from Excel and paste below. Include the header row. Or upload the Excel file. Use the format that Dashboard exports (but delete the top merged row first so that actual headers are now in the top row).</p>
                </div>
                
                <textarea id="dataInput" placeholder="Paste your data here..."></textarea>

                <div class="button-row">
                    <button class="btn" onclick="processData()">
                        <span>‚ú®</span> Process Data
                    </button>
                    <button class="btn btn-secondary" onclick="clearAll()">
                        <span>üóëÔ∏è</span> Clear All
                    </button>
                    <label for="fileInput" class="btn btn-upload">
                        <span>üìä</span> Upload Spreadsheet
                    </label>
                    <input type="file" id="fileInput" accept=".xlsx" onchange="handleFile(event)">
                </div>

                <div id="status" class="status hidden"></div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <h2><span class="step-number">2</span>Formatted Output</h2>
            </div>
            <div class="card-content">
                <div id="outputPreview"></div>
                <div class="button-row">
                    <button class="btn btn-success" onclick="copyToClipboard()">
                        <span>üìã</span> Copy to Clipboard
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let processedData = '';

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.classList.remove('hidden');
            
            setTimeout(() => {
                status.classList.add('hidden');
            }, 3000);
        }

        function processData() {
            const input = document.getElementById('dataInput').value.trim();
            
            if (!input) {
                showStatus('Please paste some data first!', 'error');
                return;
            }

            try {
                const lines = input.split('\n').filter(line => line.trim());
                
                if (lines.length < 2) {
                    showStatus('Please include header and data rows.', 'error');
                    return;
                }

                // Build column index map (case-insensitive)
                const headers = lines[0].split('\t').map(h => h.trim().toLowerCase());
                const idx = {
                    local: headers.indexOf('local'),
                    publicBody: headers.indexOf('public body'),
                    projectName: headers.indexOf('project name'),
                    awardAmount: headers.indexOf('bid award amount'),
                    contractor: headers.indexOf('bid award contractor'),
                    location: headers.indexOf('project street'),
                    startDate: headers.indexOf('tentative start date')
                };

                // Ensure required columns exist
                if (Object.values(idx).includes(-1)) {
                    throw new Error('Missing required columns');
                }

                const dataRows = lines.slice(1)
                    .map(r => r.split('\t'))
                    // Filter out rows where Bid Award Contractor (index 23) and Bid Award Amount (index 24) are empty
                    .filter(cols => cols[23]?.trim() && cols[24]?.trim())
                    .map(cols => ({
                        local: cols[idx.local]?.replace(/^LOCAL\s*/i, '').trim() || '',
                        publicBody: cols[idx.publicBody]?.trim() || '',
                        projectName: cols[idx.projectName]?.trim() || '',
                        awardAmount: cols[idx.awardAmount]?.trim() || '',
                        contractor: cols[idx.contractor]?.trim() || '',
                        location: cols[idx.location]?.trim() || '',
                        startDate: formatDate(cols[idx.startDate] || '')
                    }));

                if (dataRows.length === 0) {
                    showStatus('No rows to process (all filtered out).', 'error');
                    return;
                }

                const groupedProjects = groupByLocal(dataRows);
                processedData = formatOutput(groupedProjects);
                
                document.getElementById('outputPreview').innerHTML = processedData;
                showStatus(`Processed ${dataRows.length} projects successfully!`, 'success');

            } catch (error) {
                showStatus('Error processing data. Check format.', 'error');
                console.error('Processing error:', error);
            }
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            if (dateStr.includes('/')) {
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    const month = parts[0].padStart(2, '0');
                    const day = parts[1].padStart(2, '0');
                    let year = parts[2];
                    if (year.length === 2) {
                        year = '20' + year;
                    }
                    return `${month}/${day}/${year}`;
                }
            }
            
            return dateStr;
        }

        function groupByLocal(projects) {
            const groups = {};
            
            projects.forEach(project => {
                const local = project.local;
                if (!groups[local]) {
                    groups[local] = [];
                }
                groups[local].push(project);
            });
            
            return groups;
        }

        function formatOutput(groupedProjects) {
            let output = '';
            const locals = Object.keys(groupedProjects).sort((a, b) => {
                const numA = parseInt(a) || 0;
                const numB = parseInt(b) || 0;
                return numA - numB;
            });
            
            locals.forEach((local, groupIndex) => {
                const projects = groupedProjects[local];
                
                projects.forEach((project, projectIndex) => {
                    output += `<strong>Local:</strong> LOCAL ${project.local}<br>`;
                    output += `<strong>Public Body:</strong> ${project.publicBody}<br>`;
                    output += `<strong>Project:</strong> ${project.projectName}<br>`;
                    output += `<strong>Award Amount:</strong> ${project.awardAmount}<br>`;
                    output += `<strong>Awarded Contractor:</strong> ${project.contractor}<br>`;
                    output += `<strong>Project Location:</strong> ${project.location}<br>`;
                    output += `<strong>Estimated Start Date:</strong> ${project.startDate}<br>`;
                    
                    if (projectIndex < projects.length - 1) {
                        output += '<br>';
                    }
                });
                
                if (groupIndex < locals.length - 1) {
                    output += '<br>---<br><br>';
                }
            });
            
            return output;
        }

        async function copyToClipboard() {
            if (!processedData) {
                showStatus('No data to copy. Process data first.', 'error');
                return;
            }

            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = processedData;
                
                if (navigator.clipboard && navigator.clipboard.write) {
                    const htmlBlob = new Blob([processedData], { type: 'text/html' });
                    const textContent = tempDiv.textContent || tempDiv.innerText || '';
                    const textBlob = new Blob([textContent], { type: 'text/plain' });
                    
                    const clipboardItem = new ClipboardItem({
                        'text/html': htmlBlob,
                        'text/plain': textBlob
                    });
                    
                    await navigator.clipboard.write([clipboardItem]);
                    showStatus('Copied to clipboard!', 'success');
                } else {
                    const textContent = tempDiv.textContent || tempDiv.innerText || '';
                    await navigator.clipboard.writeText(textContent);
                    showStatus('Copied (plain text)', 'success');
                }
            } catch (error) {
                showStatus('Copy failed. Select and copy manually.', 'error');
            }
        }

        function clearAll() {
            document.getElementById('dataInput').value = '';
            document.getElementById('outputPreview').innerHTML = '';
            processedData = '';
            showStatus('Data cleared.', 'success');
        }

        document.getElementById('dataInput').addEventListener('paste', function() {
            setTimeout(() => {
                if (this.value.trim()) {
                    processData();
                }
            }, 100);
        });
    </script>
    
    <!-- SheetJS (small, MIT license) -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script>
        function handleFile(evt) {
            const file = evt.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const workbook = XLSX.read(e.target.result, { type: 'binary' });
                    const sheetName = workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    // Convert to 2-D array (each row is an array of cells)
                    const json = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });

                    // Re-create TSV string for existing parser
                    const tsv = json.map(row => row.join('\t')).join('\n');
                    document.getElementById('dataInput').value = tsv;
                    processData();          // reuse current logic
                } catch (err) {
                    showStatus('Error reading file.', 'error');
                    console.error(err);
                }
            };
            reader.readAsBinaryString(file);
        }
    </script>
</body>
</html>
